#!/usr/bin/env python3

""" This is the starter code for the robot localization project """
import rospy

from std_msgs.msg import Header, String
from sensor_msgs.msg import LaserScan, PointCloud
from helper_functions import TFHelper
import random

from occupancy_field import OccupancyField
from geometry_msgs.msg import PoseStamped, PoseWithCovarianceStamped, PoseArray, Pose, Point, Quaternion
from tf.transformations import euler_from_quaternion, rotation_matrix, quaternion_from_matrix

import tf
import math
from tf import TransformListener
from tf import TransformBroadcaster

class Particle(object):
    def __init__(self,x=0.0,y=0.0,theta=0.0,w=1.0):
        # Initialize paticle position, orientation as 0, weight as 1 
        self.w = w
        self.x = x
        self.y = y
        self.theta = theta

    def as_pose(self):
        # Returns particle as Pose object
        orientation_tuple = tf.transformations.quaternion_from_euler(0, 0, self.theta) # generates orientation from euler
        return Pose(position=Point(x=self.x, y=self.y, z=0),
                    orientation=Quaternion(x=orientation_tuple[0],
                                           y=orientation_tuple[1],
                                           z=orientation_tuple[2],
                                           w=orientation_tuple[3]))


class ParticleFilter(object):
    """ The class that represents a Particle Filter ROS Node
    """
    def __init__(self):
        rospy.init_node('pf')
        self.num_particles = 300
        self.particle_cloud = []
        self.particle_pub = rospy.Publisher("particlecloud", PoseArray, queue_size=10) 
        self.base_frame = "base_link"  # the frame of the robot base
        self.map_frame = "map"  # the name of the map coordinate frame
        self.odom_frame = "odom"  # the name of the odometry coordinate frame
        self.scan_topic = "scan"  # the topic where we will get laser scans from

        # pose_listener responds to selection of a new approximate robot
        # location (for instance using rviz)
        rospy.Subscriber("initialpose",
                         PoseWithCovarianceStamped,
                         self.update_initial_pose)

        # enable listening for and broadcasting coordinate transforms
        self.tf_listener = TransformListener()
        self.tf_broadcaster = TransformBroadcaster()

        # laser_subscriber listens for data from the lidar
        #rospy.Subscriber(self.scan_topic, LaserScan, self.scan_received)

        # create instances of two helper objects that are provided to you
        # as part of the project
        self.occupancy_field = OccupancyField()
        self.transform_helper = TFHelper()

    def update_initial_pose(self, msg):
        """ Callback function to handle re-initializing the particle filter based on a pose estimate.
            These pose estimates could be generated by another ROS Node or could come from the rviz GUI """
        xy_theta = self.transform_helper.convert_pose_to_xy_and_theta(msg.pose.pose)
        self.initialize_particle_cloud(msg.header.stamp, xy_theta) # creates particle cloud at position passed in 
        # by message 
        print("INITIALIZING POSE")


        # Use the helper functions to fix the transform
    def initialize_particle_cloud(self, timestamp, xy_theta):
        self.particle_cloud = []
        angle_variance = math.pi/12  # POint the points in the general direction of the robot
        x_cur = xy_theta[0]
        y_cur = xy_theta[1]
        theta_cur = xy_theta[2]
        print("theta_cur: ", theta_cur)
        for i in range(self.num_particles):
            # Generate values for and add a new particle!!
            x_rel = random.uniform(-.5, .5)
            y_rel = random.uniform(-.5, .5)
            new_theta = (random.uniform(theta_cur-angle_variance, theta_cur+angle_variance) % (2*math.pi))
            # TODO: Could use a tf transform to add x and y in the robot's coordinate system
            new_particle = Particle(x_cur+x_rel, y_cur+y_rel, new_theta)
            self.particle_cloud.append(new_particle)
        print("Done initializing particles")
        self.normalize_particles()
        # publish particles (so things like rviz can see them)
        self.publish_particles()
        print("normalized correctly")
        self.update_robot_pose(timestamp)
        print("updated robot pose")

    def normalize_particles(self):
        total_weights = sum([particle.w for particle in self.particle_cloud])
        # if your weights aren't normalized then normalize them
        if total_weights != 1.0:
            for i in self.particle_cloud: i.w = i.w/total_weights

    def update_robot_pose(self, timestamp):
        """ Update the estimate of the robot's pose in the map frame given the updated particles.
            There are two logical methods for this:
                (1): compute the mean pose based on all the high weight particles
                (2): compute the most likely pose (i.e. the mode of the distribution)
        """
        # first make sure that the particle weights are normalized
        self.normalize_particles()
        print("Normalized particles in update robot pose")
        # TODO: assign the latest pose into self.robot_pose as a geometry_msgs.Pose object
        # just to get started we will fix the robot's pose to always be at the origin

        total_x = 0
        total_y = 0
        total_theta = 0
        # walk through all particles 
        for p in self.particle_cloud:
            total_x += p.x * p.w
            total_y += p.y * p.w
            total_theta += p.theta * p.w
            print("theta", p.theta)
        average_wparticle = (total_x/self.num_particles, 
                            total_y/self.num_particles, 
                            total_theta/self.num_particles)
        print("total xytheta: ", total_x, total_y, total_theta)
        print("avg weightedparticle: ", average_wparticle)
        # passing average particle position into pose
        self.robot_pose = Pose()
        print("set robot pose to", self.robot_pose)
        print(timestamp)
        self.transform_helper.fix_map_to_odom_transform(self.robot_pose, timestamp)
        print("Done fixing map to odom")

    def publish_particles(self):
        # Publish the particles so that one can see them in RVIZ
        # Convert the particles from xy_theta to pose!!
        pose_particle_cloud = []
        for p in self.particle_cloud:
            pose_particle_cloud.append(p.as_pose())
        self.particle_pub.publish(PoseArray(header=Header(stamp=rospy.Time.now(),
                                            frame_id=self.map_frame),
                                  poses=pose_particle_cloud))

    def resample_particles():
        pass 

    def run(self):
        r = rospy.Rate(5)
        print("Nathan and Adi ROS Loop code is starting!!!")
        while not(rospy.is_shutdown()):
            # in the main loop all we do is continuously broadcast the latest
            # map to odom transform
            self.transform_helper.send_last_map_to_odom_transform()
            r.sleep()


if __name__ == '__main__':
    print("starting PF")
    n = ParticleFilter()
    print("Finished starting PF")
    n.run()
