#!/usr/bin/env python3

""" This is the starter code for the robot localization project """
import rospy

from std_msgs.msg import Header, String
from sensor_msgs.msg import LaserScan, PointCloud
from helper_functions import TFHelper
import random

from occupancy_field import OccupancyField
from geometry_msgs.msg import PoseStamped, PoseWithCovarianceStamped, PoseArray, Pose, Point, Quaternion
from tf.transformations import euler_from_quaternion, rotation_matrix, quaternion_from_matrix

import tf
import math
from tf import TransformListener
from tf import TransformBroadcaster
from numpy import argmin

class Particle(object):
    def __init__(self,x=0.0,y=0.0,theta=0.0,w=1.0):
        # Initialize paticle position, orientation as 0, weight as 1 
        self.w = w
        self.x = x
        self.y = y
        self.theta = theta

    def as_pose(self):
        # Returns particle as Pose object
        orientation_tuple = tf.transformations.quaternion_from_euler(0, 0, self.theta) # generates orientation from euler
        return Pose(position=Point(x=self.x, y=self.y, z=0),
                    orientation=Quaternion(x=orientation_tuple[0],
                                           y=orientation_tuple[1],
                                           z=orientation_tuple[2],
                                           w=orientation_tuple[3]))


class ParticleFilter(object):
    """ The class that represents a Particle Filter ROS Node
    """
    def __init__(self):
        rospy.init_node('pf')
        self.initialized = False
        self.num_particles = 100
        self.d_thresh = 0.2  # the amount of linear movement before performing an update
        self.a_thresh = math.pi / 6  # the amount of angular movement before performing an update
        self.particle_cloud = []
        self.lidar_grab_range = 30
        self.lidar_points = []
        self.closest_lidar = (None, None)
        self.particle_pub = rospy.Publisher("particlecloud", PoseArray, queue_size=10) 
        self.base_frame = "base_link"  # the frame of the robot base
        self.map_frame = "map"  # the name of the map coordinate frame
        self.odom_frame = "odom"  # the name of the odometry coordinate frame
        self.scan_topic = "scan"  # the topic where we will get laser scans from

        # pose_listener responds to selection of a new approximate robot
        # location (for instance using rviz)
        rospy.Subscriber("initialpose",
                         PoseWithCovarianceStamped,
                         self.update_initial_pose)

        # enable listening for and broadcasting coordinate transforms
        self.tf_listener = TransformListener()
        self.tf_broadcaster = TransformBroadcaster()

        # laser_subscriber listens for data from the lidar
        rospy.Subscriber(self.scan_topic, LaserScan, self.scan_received)

        # create instances of two helper objects that are provided to you
        # as part of the project
        self.current_odom_xy_theta = []
        self.occupancy_field = OccupancyField()
        self.transform_helper = TFHelper()
        self.initialized = True

    def update_initial_pose(self, msg):
        """ Callback function to handle re-initializing the particle filter based on a pose estimate.
            These pose estimates could be generated by another ROS Node or could come from the rviz GUI """
        xy_theta = self.transform_helper.convert_pose_to_xy_and_theta(msg.pose.pose)
        print("xy_theta", xy_theta)
        self.initialize_particle_cloud(msg.header.stamp, xy_theta) # creates particle cloud at position passed in 
        # by message 
        print("INITIALIZING POSE")


        # Use the helper functions to fix the transform
    def initialize_particle_cloud(self, timestamp, xy_theta):
        self.particle_cloud = []
        angle_variance = math.pi/12  # POint the points in the general direction of the robot
        x_cur = xy_theta[0]
        y_cur = xy_theta[1]
        theta_cur = self.transform_helper.angle_normalize(xy_theta[2])
        # print("theta_cur: ", theta_cur)
        for i in range(self.num_particles):
            # Generate values for and add a new particle!!
            x_rel = random.uniform(-.5, .5)
            y_rel = random.uniform(-.5, .5)
            new_theta = (random.uniform(theta_cur-angle_variance, theta_cur+angle_variance))
            # TODO: Could use a tf transform to add x and y in the robot's coordinate system
            new_particle = Particle(x_cur+x_rel, y_cur+y_rel, new_theta)
            self.particle_cloud.append(new_particle)
        print("Done initializing particles")
        self.normalize_particles()
        # publish particles (so things like rviz can see them)
        self.publish_particles()
        print("normalized correctly")
        self.update_robot_pose(timestamp)
        print("updated robot pose")

    def normalize_particles(self):
        total_weights = sum([particle.w for particle in self.particle_cloud])
        # if your weights aren't normalized then normalize them
        if total_weights != 1.0:
            for i in self.particle_cloud: i.w = i.w/total_weights

    def calculate_weights(self):    
        """
        Calculate particle weights based off of euclidean distance  
        """
        # walk through all particles, set weight based off distance to closest obstacle vs distance to closest lidar point
        for p in self.particle_cloud:
            for lp in self.lidar_points:
                
                closest = self.occupancy_field.get_closest_obstacle_distance(p.x, p.y)
                # TODO handle NaN return
                print("closest from occ_field: ", closest)
                p.w = 1 / self.calculate_min_distance(closest)
                print(p.w)

    def calculate_min_distance(self, closest):
        """
        calculate distance from closest obstacle to self.min_lidar_point
        """
        pass
                

    def update_robot_pose(self, timestamp):
        """ Update the estimate of the robot's pose in the map frame given the updated particles.
            There are two logical methods for this:
                (1): compute the mean pose based on all the high weight particles
                (2): compute the most likely pose (i.e. the mode of the distribution)
        """
        # first make sure that the particle weights are normalized
        self.normalize_particles()
        print("Normalized particles in update robot pose")
        # TODO: assign the latest pose into self.robot_pose as a geometry_msgs.Pose object
        # just to get started we will fix the robot's pose to always be at the origin

        average_x = 0
        average_y = 0
        average_theta = 0
        # walk through all particles, calculate weighted average for x, y, z, in particle map. 
        for p in self.particle_cloud:
            average_x += p.x * p.w
            average_y += p.y * p.w
            average_theta += p.theta * p.w
            # print("theta", p.theta)
        print("average x,y,theta: ", average_x, average_y, average_theta)

        # create new particle representing weighted average values, pass in Pose to new robot pose
        average_particle = Particle(average_x,average_y, average_theta)
        self.robot_pose = average_particle.as_pose()
        print("set robot pose to", self.robot_pose)
        print(timestamp)
        self.transform_helper.fix_map_to_odom_transform(self.robot_pose, timestamp)
        print("Done fixing map to odom")

    def publish_particles(self):
        # Publish the particles so that one can see them in RVIZ
        # Convert the particles from xy_theta to pose!!
        pose_particle_cloud = []
        for p in self.particle_cloud:
            pose_particle_cloud.append(p.as_pose())
        self.particle_pub.publish(PoseArray(header=Header(stamp=rospy.Time.now(),
                                            frame_id=self.map_frame),
                                  poses=pose_particle_cloud))

    def resample_particles(self):
        pass 

    def update_particles_with_odom(self, msg):
        """ Update the particles using the newly given odometry pose.
            The function computes the value delta which is a tuple (x,y,theta)
            that indicates the change in position and angle between the odometry
            when the particles were last updated and the current odometry.
            msg: this is not really needed to implement this, but is here just in case.
        """
        new_odom_xy_theta = self.transform_helper.convert_pose_to_xy_and_theta(self.odom_pose.pose)
        # compute the change in x,y,theta since our last update
        if self.current_odom_xy_theta:
            old_odom_xy_theta = self.current_odom_xy_theta
            delta = (new_odom_xy_theta[0] - self.current_odom_xy_theta[0],
                     new_odom_xy_theta[1] - self.current_odom_xy_theta[1],
                     new_odom_xy_theta[2] - self.current_odom_xy_theta[2])

            delta_pose = Particle(delta[0], delta[1], delta[2]).as_pose()

            # self.delta_map_pose = self.tf_listener.transformPose(self.map_frame, p)
            # # store the the odometry pose in a more convenient format (x,y,theta)
            # converted_pose = self.transform_helper.convert_pose_to_xy_and_theta(self.delta_map_pose.pose)
            #
            # print("Robot was at:")
            # print(self.current_odom_xy_theta)
            # print("Now the robot is at: ")
            # print(new_odom_xy_theta)
            # print("moved x: ", delta[0])
            # print("moved y: ", delta[1])
            # print("moved *: ", delta[2])
            # print(self.particle_cloud[0].x, self.particle_cloud[0].y,self.particle_cloud[0].theta)
            # print(converted_pose)
            ang_of_dest = math.atan2(delta[1], delta[0])

            ang_to_dest = self.transform_helper.angle_diff(self.current_odom_xy_theta[2], ang_of_dest)
            print("moved x: ", delta[0])
            print("moved y: ", delta[1])
            print("Curr", self.current_odom_xy_theta[2], "Dest",ang_of_dest)
            print("ANGLE TO TURN: ",ang_to_dest, "\n")
            d = math.sqrt(delta[0]**2 + delta[1]**2)
            print("Distance: ", d)



            self.current_odom_xy_theta = new_odom_xy_theta
        else:
            self.current_odom_xy_theta = new_odom_xy_theta
            return
        for p in self.particle_cloud:
            # Subtract since Odom is inverted from map

            # Add first rotation
            phi = p.theta+ang_to_dest
            print("phi", phi)
            p.x += math.cos(phi) * d
            p.y += math.sin(phi) * d
            p.theta += self.transform_helper.angle_normalize(delta[2])

            # p.x += delta[0] * math.cos(p.theta) - delta[1] * math.sin(p.theta)
            # p.y += delta[0] * math.sin(p.theta) + delta[1] * math.cos(p.theta)
            # p.theta += delta[2]
        self.current_odom_xy_theta = new_odom_xy_theta

    def scan_received(self, msg): 
        """
        Callback to recieve laser scan - should pass data into global scan object
        """
        # self.lidar_points = msg.ranges[-self.lidar_grab_range:]
        # self.lidar_points.extend(msg.ranges[:self.lidar_grab_range])
        # self.calculate_weights()
        # self.closest_lidar = (min(msg.ranges), argmin(msg.ranges))
        """ This is the default logic for what to do when processing scan data.
            Feel free to modify this, however, we hope it will provide a good
            guide.  The input msg is an object of type sensor_msgs/LaserScan """
        if not(self.initialized):
            # wait for initialization to complete
            return

        if not(self.tf_listener.canTransform(self.base_frame, msg.header.frame_id, msg.header.stamp)):
            # need to know how to transform the laser to the base frame
            # this will be given by either Gazebo or neato_node
            return

        if not(self.tf_listener.canTransform(self.base_frame, self.odom_frame, msg.header.stamp)):
            # need to know how to transform between base and odometric frames
            # this will eventually be published by either Gazebo or neato_node
            return

        # calculate pose of laser relative to the robot base
        p = PoseStamped(header=Header(stamp=rospy.Time(0),
                                      frame_id=msg.header.frame_id))
        self.laser_pose = self.tf_listener.transformPose(self.base_frame, p)

        # find out where the robot thinks it is based on its odometry
        p = PoseStamped(header=Header(stamp=msg.header.stamp,
                                      frame_id=self.base_frame),
                        pose=Pose())
        self.odom_pose = self.tf_listener.transformPose(self.odom_frame, p)
        # store the the odometry pose in a more convenient format (x,y,theta)
        new_odom_xy_theta = self.transform_helper.convert_pose_to_xy_and_theta(self.odom_pose.pose)
        if not self.current_odom_xy_theta:
            self.current_odom_xy_theta = new_odom_xy_theta
            return

        if not(self.particle_cloud):
            # now that we have all of the necessary transforms we can update the particle cloud
            self.initialize_particle_cloud(msg.header.stamp)
        elif (math.fabs(new_odom_xy_theta[0] - self.current_odom_xy_theta[0]) > self.d_thresh or
              math.fabs(new_odom_xy_theta[1] - self.current_odom_xy_theta[1]) > self.d_thresh or
              math.fabs(new_odom_xy_theta[2] - self.current_odom_xy_theta[2]) > self.a_thresh):
            # we have moved far enough to do an update!
            self.update_particles_with_odom(msg)    # update based on odometry
            print("UPDATED PARTICLES VIA ODOM")
        #
        #     self.update_particles_with_laser(msg)   # update based on laser scan
        #    self.update_robot_pose(msg.header.stamp)                # update robot's pose
        #     self.resample_particles()               # resample particles to focus on areas of high density
        # # publish particles (so things like rviz can see them)
        self.publish_particles()


    def run(self):
        r = rospy.Rate(5)
        print("Nathan and Adi ROS Loop code is starting!!!")
        while not(rospy.is_shutdown()):
            # in the main loop all we do is continuously broadcast the latest
            # map to odom transform
            self.transform_helper.send_last_map_to_odom_transform()
            r.sleep()


if __name__ == '__main__':
    print("starting PF")
    n = ParticleFilter()
    print("Finished starting PF")
    n.run()
